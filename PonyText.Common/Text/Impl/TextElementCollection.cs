// File: TextElementCollection.cs 
// Copyright 2020 Zelong Ou. All Rights Reserved.
// Licensed under the GNU General Public License v3.0

using System.Collections;
using System.Collections.Generic;
using System.Text;
using PonyText.Common.Context;
using PonyText.Common.Processor;
using PonyText.Common.Renderer;
using PonyText.Common.Text;

namespace PonyText.Common.Text.Impl {
    public class TextElementCollection : AbstractTextElement, IEnumerable<AbstractTextElement> {
        List<AbstractTextElement> generalDocument;
        public TextElementCollection() : base(TextElementType.TextElementCollection) {
            generalDocument = new List<AbstractTextElement>();
        }

        public List<AbstractTextElement> getDocument() {
            return generalDocument;
        }

        public override void AddTextElement(AbstractTextElement abstractTextElement) {
            if (abstractTextElement.TextElementType == TextElementType.Paragraph ||
                abstractTextElement.TextElementType == TextElementType.TextElementCollection ||
                abstractTextElement.TextElementType == TextElementType.TextDirective/* ||
                abstractTextElement.TextElementType == TextElementType.TextUnit*/) {
                generalDocument.Add(abstractTextElement);
            }
            else {
                // if just a single text, then it must be generated by preprocessor
                // which mean it is not the semantically paragraph (pure text written directly by
                // human and with LF followed by)


                // If previous is paragraph, then merge into it.
                AbstractTextElement last;
                if (generalDocument.Count > 0 &&
                    (last = generalDocument[generalDocument.Count - 1]).TextElementType == TextElementType.Paragraph) {
                    last.AddTextElement(abstractTextElement);
                }
                else {
                    // If previous is other stuff, then make it as a new paragraph
                    AbstractTextElement paragraph = new Paragraph();
                    paragraph.AddTextElement(abstractTextElement);
                    generalDocument.Add(paragraph);
                }
                //AbstractTextElement paragraph = new Paragraph();
                //paragraph.AddTextElement(abstractTextElement);
                //generalDocument.Add(paragraph);
            }
        }

        public IEnumerator<AbstractTextElement> GetEnumerator() {
            return generalDocument.GetEnumerator();
        }

        public override void Render(AbstractRendererBase rendererBase, PonyTextContext textContext) {
            rendererBase.EnterRenderContext(CustomProperty);
            AbstractProcessor abstractProcessor = null;
            if (CustomProperty.HasProperty(AbstractProcessor.RENDER_PROCESSOR_PROPERTY)) {
                var processor = CustomProperty.GetProperty(AbstractProcessor.RENDER_PROCESSOR_PROPERTY) as string;
                abstractProcessor = textContext.ProcessorFactory.GetRenderProcessor(processor);
                abstractProcessor.PreRendering(textContext, rendererBase, this);
            }
            foreach (var text in generalDocument) {
                text.Render(rendererBase, textContext);
            }
            abstractProcessor?.PostRendering(textContext, rendererBase, this);
            rendererBase.LeaveRenderContext();
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return generalDocument.GetEnumerator();
        }

        public override string ToString() {
            var strs = new List<string>();
            foreach (var item in generalDocument) {
                strs.Add(item.ToString());
            }
            var sb = new StringBuilder();
            sb.Append($"{{{base.ToString()},");
            sb.Append($"\"Paragraphs\": [");
            sb.AppendJoin(',', strs);
            sb.Append("]}");
            return sb.ToString();
        }
    }
}
